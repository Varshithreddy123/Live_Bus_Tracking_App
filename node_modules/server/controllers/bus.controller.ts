import { Request, Response, NextFunction } from "express";
import prisma from "@/utils/prisma";

// Get nearby bus stands based on user's location
export const getNearbyBusStands = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { latitude, longitude, radius = 1000 } = req.query;

    if (!latitude || !longitude) {
      return res.status(400).json({
        success: false,
        message: "Latitude and longitude are required"
      });
    }

    const lat = parseFloat(latitude as string);
    const lng = parseFloat(longitude as string);
    const rad = parseFloat(radius as string);

    const busStands = await prisma.busStand.findMany();

    const nearbyStands = busStands.filter(stand => {
      const distance = calculateDistance(lat, lng, stand.latitude, stand.longitude);
      return distance <= rad;
    });

    res.json({
      success: true,
      data: nearbyStands.map(stand => ({
        id: stand.id,
        name: stand.name,
        latitude: stand.latitude,
        longitude: stand.longitude,
        address: stand.address,
        distance: calculateDistance(lat, lng, stand.latitude, stand.longitude)
      }))
    });
  } catch (error) {
    console.error("Error fetching nearby bus stands:", error);
    next(error);
  }
};

// Get all bus routes
export const getBusRoutes = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const routes = await prisma.route.findMany({
      include: {
        stops: {
          include: {
            busStand: true
          },
          orderBy: {
            order: 'asc'
          }
        }
      }
    });

    res.json({
      success: true,
      data: routes.map(route => ({
        id: route.id,
        name: route.name,
        busNumber: route.busNumber,
        stops: route.stops.map(stop => ({
          id: stop.busStand.id,
          name: stop.busStand.name,
          latitude: stop.busStand.latitude,
          longitude: stop.busStand.longitude,
          order: stop.order,
          eta: stop.eta
        })),
        polyline: route.polyline ? JSON.parse(route.polyline) : null
      }))
    });
  } catch (error) {
    console.error("Error fetching bus routes:", error);
    next(error);
  }
};

// Get live bus location for a specific route
export const getLiveBusLocation = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { routeId } = req.params;

    if (!routeId) {
      return res.status(400).json({
        success: false,
        message: "Route ID is required"
      });
    }

    const route = await prisma.route.findUnique({
      where: { id: routeId },
      include: {
        stops: {
          include: {
            busStand: true
          },
          orderBy: {
            order: 'asc'
          }
        }
      }
    });

    if (!route) {
      return res.status(404).json({
        success: false,
        message: "Route not found"
      });
    }

    const mockLiveData = {
      busNumber: route.busNumber,
      routeName: route.name,
      currentLocation: {
        latitude: route.stops[0]?.busStand.latitude || 0,
        longitude: route.stops[0]?.busStand.longitude || 0
      },
      currentStop: route.stops[0]?.busStand.name,
      nextStop: route.stops[1]?.busStand.name,
      eta: "5 mins",
      distance: "2.3 km",
      speed: "25 km/h",
      occupancy: "60%",
      isActive: true,
      stops: route.stops.map(stop => ({
        id: stop.busStand.id,
        name: stop.busStand.name,
        latitude: stop.busStand.latitude,
        longitude: stop.busStand.longitude,
        eta: stop.eta
      })),
      routePolyline: route.polyline ? JSON.parse(route.polyline) : []
    };

    res.json({
      success: true,
      data: mockLiveData
    });
  } catch (error) {
    console.error("Error fetching live bus location:", error);
    next(error);
  }
};

// List available buses between from/to stops by route containment
// GET /bus/available?from=StartStop&to=EndStop
export const getAvailableBuses = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { from, to } = req.query as { from?: string; to?: string };

    if (!from || !to) {
      return res.status(400).json({ success: false, message: "'from' and 'to' are required" });
    }

    const [fromStands, toStands] = await Promise.all([
      prisma.busStand.findMany({ where: { name: { contains: from as string, mode: 'insensitive' } } }),
      prisma.busStand.findMany({ where: { name: { contains: to as string, mode: 'insensitive' } } })
    ]);

    if (fromStands.length === 0 || toStands.length === 0) {
      return res.json({ success: true, data: [] });
    }

    const fromIds = new Set(fromStands.map(s => s.id));
    const toIds = new Set(toStands.map(s => s.id));

    const routes = await prisma.route.findMany({
      include: {
        stops: {
          include: { busStand: true },
          orderBy: { order: 'asc' }
        }
      }
    });

    const matching = routes
      .map(route => {
        const stops = route.stops;
        let fromIndex: number | null = null;
        let toIndex: number | null = null;
        for (let i = 0; i < stops.length; i++) {
          const s = stops[i];
          if (fromIndex === null && fromIds.has(s.busStandId)) {
            fromIndex = i;
          }
          if (fromIndex !== null && toIds.has(s.busStandId)) {
            toIndex = i;
            break;
          }
        }
        if (fromIndex !== null && toIndex !== null && fromIndex < toIndex) {
          return {
            id: route.id,
            name: route.name,
            busNumber: route.busNumber,
            fromStop: {
              id: stops[fromIndex].busStand.id,
              name: stops[fromIndex].busStand.name,
              eta: stops[fromIndex].eta
            },
            toStop: {
              id: stops[toIndex].busStand.id,
              name: stops[toIndex].busStand.name,
              eta: stops[toIndex].eta
            },
            totalStops: stops.length
          };
        }
        return null;
      })
      .filter(Boolean);

    res.json({ success: true, data: matching });
  } catch (error) {
    console.error('Error fetching available buses:', error);
    next(error);
  }
};

// Helper function to calculate distance between two points (meters)
function calculateDistance(lat1: number, lon1: number, lat2: number, lon2: number): number {
  const R = 6371; // Radius of the Earth in km
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLon = (lon2 - lon1) * Math.PI / 180;
  const a =
    Math.sin(dLat/2) * Math.sin(dLat/2) +
    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
    Math.sin(dLon/2) * Math.sin(dLon/2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  const distance = R * c; // Distance in km
  return distance * 1000; // Convert to meters
}
